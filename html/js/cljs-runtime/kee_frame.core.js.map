{"version":3,"sources":["kee_frame/core.cljc"],"mappings":"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","names":["kee-frame.core/kee-frame-interceptors","kee-frame.spec/spec-interceptor","kee-frame.state/app-db-spec","kee-frame.debug/debug-interceptor","kee-frame.state/debug?","re-frame.core/trim-v","kee-frame.core/valid-option-key?","kee-frame.core/extra-options","options","cljs.core.filter","p__41282","vec__41283","cljs.core.nth","k","cljs.core/not","cljs.core.into","kee-frame.core/start!","cljs.spec.alpha.valid_QMARK_","expound.alpha.expound","cljs.core.ex_info","cljs.spec.alpha/explain-data","extras","cljs.core/seq","kee-frame.router/start!","kee-frame.core/debug-enabled?","map__41287","cljs.core/deref","cljs.core/--destructure-map","cljs.core.get","overwrites?","kee-frame.state/debug-config","and__4210__auto__","kee-frame.core/reg-controller","id","controller","kee-frame.state/controllers","re-frame.core/console","cljs.core.swap_BANG_","cljs.core/assoc","var_args","G__41289","kee-frame.core/reg-event-fx","js/Error","handler","kee_frame.core.reg_event_fx","interceptors","re_frame.core.reg_event_fx","cljs.core.concat","G__41291","kee-frame.core/reg-event-db","kee_frame.core.reg_event_db","re_frame.core.reg_event_db","args__4824__auto__","len__4818__auto__","i__4819__auto__","argseq__4825__auto__","cljs.core/IndexedSeq","kee-frame.core/reg-chain-named","seq41292","self__4806__auto__","handlers","cljs.core.apply","re-chain.core/reg-chain-named*","kee-frame.core/reg-chain","seq41293","G__41294","cljs.core/first","cljs.core/next","self__4805__auto__","re-chain.core/reg-chain*","kee-frame.core/path-for","seq41295","G__41296","params","kee-frame.router/url","kee-frame.core/switch-route","seq41297","G__41298","f","pairs","kee-frame.router/switch-route"],"sourcesContent":["(ns kee-frame.core\n  (:require [kee-frame.state :as state]\n            [kee-frame.router :as router]\n            [re-chain.core :as chain]\n            [re-frame.core :as rf :refer [console]]\n            [kee-frame.spec :as spec :refer [spec-interceptor]]\n            [kee-frame.debug :refer [debug-interceptor]]\n            [clojure.spec.alpha :as s]\n            [expound.alpha :as e]))\n\n;; Interceptors used by all chains and events registered through kee-frame\n(def kee-frame-interceptors [(spec-interceptor state/app-db-spec) (debug-interceptor state/debug?) rf/trim-v])\n\n(def valid-option-key? #{:router :hash-routing? :routes :process-route :debug? :debug-config\n                         :chain-links :app-db-spec :root-component :initial-db\n                         :screen :scroll})\n\n(defn extra-options\n  \"Complete listing of invalid options sent to the `start!` function.\"\n  [options]\n  (->> options\n       (filter (fn [[k]] (not (valid-option-key? k))))\n       (into {})))\n\n(defn start!\n  \"Starts your client application with the specified `options`.\n\n  This function is intentionally forgiving in certain ways:\n  - You can call it as often as you want. Figwheel should call it on each code change\n  - You can omit the `options` altogether. kee-frame chooses sensible defaults for you and leads the way.\n\n  Usage:\n  ```\n  (k/start! {:debug?         true\n             :routes         my-reitit-routes\n             :hash-routing?  true\n             :initial-db     {:some-property \\\"default value\\\"}\n             :root-component [my-reagent-root-component]\n             :app-db-spec    :spec/my-db-spec})\n  ```\"\n  [options]\n  (when-not (s/valid? ::spec/start-options options)\n    (e/expound ::spec/start-options options)\n    (throw (ex-info \"Invalid options\" (s/explain-data ::spec/start-options options))))\n  (let [extras (extra-options options)]\n    (when (seq extras)\n      (throw (ex-info (str \"Uknown startup options. Valid keys are \" valid-option-key?) extras))))\n  (router/start! options))\n\n(defn debug-enabled? []\n  (let [{:keys [overwrites?]\n         :or   {overwrites? false}} @state/debug-config]\n    (and @state/debug?\n         overwrites?)))\n\n(defn reg-controller\n  \"Put a controller config map into the global controller registry.\n\n  Parameters:\n\n  `id`: Must be unique in controllere registry. Will appear in logs.\n\n  `controller`: A map with the following keys:\n  - `:params`: A function that receives the route data and returns the part that should be sent to the `start` function. A nil\n  return means that the controller should not run for this route.\n\n  - `:start`: A function or an event vector. Called when `params` returns a non-nil value different from the previous\n  invocation. The function receives whatever non-nil value that was returned from `params`,\n  and returns a re-frame event vector. If the function does nothing but returning the vector, the surrounding function\n  can be omitted.\n\n  - `:stop`: Optional. A function or an event vector. Called when previous invocation of `params` returned non-nil and the\n  current invocation returned nil. If the function does nothing but returning the vector, the surrounding function\n  can be omitted.\"\n  [id controller]\n  (when-not (s/valid? ::spec/controller controller)\n    (e/expound ::spec/controller controller)\n    (throw (ex-info \"Invalid controller\" (s/explain-data ::spec/controller controller))))\n  (when (and (debug-enabled?)\n             (get @state/controllers id))\n    (console :warn \"Overwriting controller with id \" id))\n  (swap! state/controllers assoc id controller))\n\n(defn reg-event-fx\n  \"Exactly same signature as `re-frame.core/reg-event-fx`. Use this version if you want kee-frame logging and spec validation.\n\n  `re-frame.core/trim-v` interceptor is also applied.\"\n  ([id handler] (reg-event-fx id nil handler))\n  ([id interceptors handler] (rf/reg-event-fx id (concat kee-frame-interceptors interceptors) handler)))\n\n(defn reg-event-db\n  \"Exactly same signature as `re-frame.core/reg-event-db`. Use this version if you want kee-frame logging and spec validation.\n\n  `re-frame.core/trim-v` interceptor is also applied.\"\n  ([id handler] (reg-event-db id nil handler))\n  ([id interceptors handler] (rf/reg-event-db id (concat kee-frame-interceptors interceptors) handler)))\n\n(defn reg-chain-named\n  \"Same as `reg-chain`, but with manually named event handlers. Useful when you need more meaningful names in your\n  event log.\n\n  Parameters:\n\n  `handlers`: pairs of id and event handler.\n\n  Usage:\n  ```\n  (k/reg-chain-named\n\n    :load-customer-data\n    (fn [ctx [customer-id]]\n      {:http-xhrio {:uri \\\"...\\\"}})\n\n    :receive-customer-data\n     (fn [ctx [customer-id customer-data]]\n      (assoc-in ctx [:db :customers customer-id] customer-data)))\n  ```\"\n  [& handlers]\n  (apply chain/reg-chain-named* kee-frame-interceptors handlers))\n\n(defn reg-chain\n  \"Register a list of re-frame fx handlers, chained together.\n\n  The chaining is done through dispatch inference. https://github.com/Day8/re-frame-http-fx is supported by default,\n  you can easily add your own like this: https://github.com/ingesolvoll/kee-frame#configuring-chains-since-020.\n\n  Each handler's event vector is prepended with accumulated event vectors of previous handlers. So if the first handler\n  receives [a b], and the second handler normally would receive [c], it will actually receive [a b c]. The purpose is\n  to make all context available to the entire chain, without a complex framework or crazy scope tricks.\n\n  Parameters:\n\n  `id`: the id of the first re-frame event. The next events in the chain will get the same id followed by an index, so\n  if your id is `add-todo`, the next one in chain will be called `add-todo-1`.\n\n  `handlers`: re-frame event handler functions, registered with `kee-frame.core/reg-event-fx`.\n\n\n  Usage:\n  ```\n  (k/reg-chain\n    :load-customer-data\n\n    (fn [ctx [customer-id]]\n      {:http-xhrio {:uri    (str \\\"/customer/\\\" customer-id)\n                    :method :get}})\n\n    (fn [cxt [customer-id customer-data]\n      (assoc-in ctx [:db :customers customer-id] customer-data)))\n  ```\"\n  [id & handlers]\n  (apply chain/reg-chain* id kee-frame-interceptors handlers))\n\n(defn path-for\n  \"Make a uri from route data. Useful for avoiding hard coded links in your app.\n\n  Parameters:\n\n  `handler`: The reitit handler from route data\n\n  `params`: Reitit route params for the requested route\n\n  Usage: `[:a {:href (k/path-for [:orders :sort-by :date]} \\\"Orders sorted by date\\\"]`\"\n  [handler & params]\n  (apply router/url handler params))\n\n(defn switch-route\n  \"Reagent component that renders different components for different routes.\n\n  You might need to include a case for `nil`, since there are no route data before the first navigation.\n\n  Parameters:\n\n  `f`: A function that receives the route data on every route change, and returns the value to dispatch on.\n\n  `pairs`: A pair consists of the dispatch value and the reagent component to dispatch to.\n\n  Returns the first component with a matching dispatch value.\n\n  Usage:\n  ```\n  [k/switch-route (fn [route] (:handler route))\n    :index [:div \\\"This is index page\\\"]\n    :about [:div \\\"This is the about page\\\"]\n    nil    [:div \\\"Probably also the index page\\\"]]\n  ```\"\n  [f & pairs]\n  (apply router/switch-route f pairs))\n"]}